/**
 * Fixed DOCX Generator UMD Module
 * Self-contained Word document generator with ZIP functionality
 * Compatible with GitHub Pages hosting
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory();
  } else {
    root.docx = factory();
  }
}(typeof self !== 'undefined' ? self : this, function () {
  'use strict';

  // Simple ZIP implementation for creating .docx files
  class SimpleZip {
    constructor() {
      this.files = {};
    }

    file(path, content) {
      this.files[path] = content;
      return this;
    }

    generateAsync(options) {
      return new Promise((resolve) => {
        const zip = this.createZipFile();
        resolve(zip);
      });
    }

    createZipFile() {
      const files = Object.keys(this.files);
      const fileData = files.map(path => ({
        path,
        content: this.files[path]
      }));

      // Create ZIP file structure
      const zipData = this.buildZipStructure(fileData);
      return new Uint8Array(zipData);
    }

    buildZipStructure(files) {
      const zipArray = [];
      const centralDir = [];
      let offset = 0;

      // Add files
      files.forEach(file => {
        const content = new TextEncoder().encode(file.content);
        const pathBytes = new TextEncoder().encode(file.path);
        
        // Local file header
        const localHeader = this.createLocalFileHeader(pathBytes, content);
        zipArray.push(...localHeader);
        zipArray.push(...pathBytes);
        zipArray.push(...content);

        // Central directory entry
        const centralEntry = this.createCentralDirEntry(pathBytes, content, offset);
        centralDir.push(...centralEntry);
        centralDir.push(...pathBytes);

        offset += localHeader.length + pathBytes.length + content.length;
      });

      // Central directory
      const centralDirOffset = zipArray.length;
      zipArray.push(...centralDir);

      // End of central directory
      const endOfCentralDir = this.createEndOfCentralDir(files.length, centralDir.length, centralDirOffset);
      zipArray.push(...endOfCentralDir);

      return zipArray;
    }

    createLocalFileHeader(pathBytes, content) {
      const header = new ArrayBuffer(30);
      const view = new DataView(header);
      
      view.setUint32(0, 0x04034b50, true); // Local file header signature
      view.setUint16(4, 20, true); // Version needed to extract
      view.setUint16(6, 0, true); // General purpose bit flag
      view.setUint16(8, 0, true); // Compression method (stored)
      view.setUint16(10, 0, true); // Last mod file time
      view.setUint16(12, 0, true); // Last mod file date
      view.setUint32(14, this.crc32(content), true); // CRC-32
      view.setUint32(18, content.length, true); // Compressed size
      view.setUint32(22, content.length, true); // Uncompressed size
      view.setUint16(26, pathBytes.length, true); // File name length
      view.setUint16(28, 0, true); // Extra field length

      return new Uint8Array(header);
    }

    createCentralDirEntry(pathBytes, content, offset) {
      const entry = new ArrayBuffer(46);
      const view = new DataView(entry);
      
      view.setUint32(0, 0x02014b50, true); // Central directory file header signature
      view.setUint16(4, 20, true); // Version made by
      view.setUint16(6, 20, true); // Version needed to extract
      view.setUint16(8, 0, true); // General purpose bit flag
      view.setUint16(10, 0, true); // Compression method
      view.setUint16(12, 0, true); // Last mod file time
      view.setUint16(14, 0, true); // Last mod file date
      view.setUint32(16, this.crc32(content), true); // CRC-32
      view.setUint32(20, content.length, true); // Compressed size
      view.setUint32(24, content.length, true); // Uncompressed size
      view.setUint16(28, pathBytes.length, true); // File name length
      view.setUint16(30, 0, true); // Extra field length
      view.setUint16(32, 0, true); // File comment length
      view.setUint16(34, 0, true); // Disk number start
      view.setUint16(36, 0, true); // Internal file attributes
      view.setUint32(38, 0, true); // External file attributes
      view.setUint32(42, offset, true); // Relative offset of local header

      return new Uint8Array(entry);
    }

    createEndOfCentralDir(fileCount, centralDirSize, centralDirOffset) {
      const end = new ArrayBuffer(22);
      const view = new DataView(end);
      
      view.setUint32(0, 0x06054b50, true); // End of central directory signature
      view.setUint16(4, 0, true); // Number of this disk
      view.setUint16(6, 0, true); // Number of the disk with the start of the central directory
      view.setUint16(8, fileCount, true); // Total number of entries in the central directory on this disk
      view.setUint16(10, fileCount, true); // Total number of entries in the central directory
      view.setUint32(12, centralDirSize, true); // Size of the central directory
      view.setUint32(16, centralDirOffset, true); // Offset of start of central directory
      view.setUint16(20, 0, true); // ZIP file comment length

      return new Uint8Array(end);
    }

    crc32(data) {
      const table = this.makeCRCTable();
      let crc = 0 ^ (-1);
      
      for (let i = 0; i < data.length; i++) {
        crc = (crc >>> 8) ^ table[(crc ^ data[i]) & 0xFF];
      }
      
      return (crc ^ (-1)) >>> 0;
    }

    makeCRCTable() {
      if (SimpleZip.crcTable) return SimpleZip.crcTable;
      
      const table = [];
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[i] = c;
      }
      SimpleZip.crcTable = table;
      return table;
    }
  }

  // Helper function to escape XML properly
  function escapeXml(unsafe) {
    if (typeof unsafe !== 'string') return '';
    return unsafe
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  // Heading levels
  const HeadingLevel = {
    TITLE: 'Title',
    HEADING_1: 'Heading1',
    HEADING_2: 'Heading2',
    HEADING_3: 'Heading3'
  };

  // Paragraph class
  function Paragraph(options) {
    if (typeof options === 'string') {
      this.text = options;
      this.heading = null;
    } else if (options && typeof options === 'object') {
      this.text = options.text || '';
      this.heading = options.heading || null;
    } else {
      this.text = '';
      this.heading = null;
    }
  }

  // Document class
  function Document(options) {
    this.sections = options && options.sections ? options.sections : [];
  }

  // Packer class
  const Packer = {
    toBlob: async function(doc) {
      const zip = new SimpleZip();
      
      // Add required files for .docx
      zip.file('[Content_Types].xml', createContentTypesXml());
      zip.file('_rels/.rels', createMainRelsXml());
      zip.file('word/_rels/document.xml.rels', createDocumentRelsXml());
      zip.file('word/document.xml', createDocumentXml(doc));
      zip.file('word/styles.xml', createStylesXml());
      zip.file('word/fontTable.xml', createFontTableXml());
      zip.file('word/settings.xml', createSettingsXml());
      zip.file('docProps/app.xml', createAppXml());
      zip.file('docProps/core.xml', createCoreXml());

      const zipData = await zip.generateAsync({type: 'uint8array'});
      return new Blob([zipData], { 
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
      });
    }
  };

  // XML generation functions
  function createContentTypesXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>
  <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
</Types>`;
  }

  function createMainRelsXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
</Relationships>`;
  }

  function createDocumentRelsXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable" Target="fontTable.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
</Relationships>`;
  }

  function createDocumentXml(doc) {
    let bodyContent = '';
    
    if (doc.sections && doc.sections.length > 0) {
      doc.sections.forEach(section => {
        if (section.children) {
          section.children.forEach(paragraph => {
            bodyContent += generateParagraphXml(paragraph);
          });
        }
      });
    }

    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <w:body>
${bodyContent}
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="708" w:footer="708" w:gutter="0"/>
      <w:cols w:space="708"/>
      <w:docGrid w:linePitch="360"/>
    </w:sectPr>
  </w:body>
</w:document>`;
  }

  function generateParagraphXml(paragraph) {
    const text = escapeXml(paragraph.text || '');
    let pPrXml = '';
    
    if (paragraph.heading) {
      pPrXml = `      <w:pPr>
        <w:pStyle w:val="${paragraph.heading}"/>
      </w:pPr>
`;
    }

    // Handle empty paragraphs
    if (!text.trim()) {
      return `    <w:p>
${pPrXml}    </w:p>
`;
    }

    // Handle line breaks properly - split by newlines and create separate runs
    const lines = text.split('\n');
    let runsXml = '';
    
    for (let i = 0; i < lines.length; i++) {
      if (i > 0) {
        // Add line break between lines
        runsXml += '      <w:r><w:br/></w:r>\n';
      }
      
      // Add the text run (even if empty to preserve spacing)
      runsXml += `      <w:r>
        <w:t xml:space="preserve">${lines[i]}</w:t>
      </w:r>
`;
    }

    return `    <w:p>
${pPrXml}${runsXml}    </w:p>
`;
  }

  function createStylesXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:docDefaults>
    <w:rPrDefault>
      <w:rPr>
        <w:rFonts w:ascii="Calibri" w:eastAsia="Calibri" w:hAnsi="Calibri" w:cs="Calibri"/>
        <w:sz w:val="22"/>
        <w:szCs w:val="22"/>
        <w:lang w:val="en-US" w:eastAsia="en-US" w:bidi="ar-SA"/>
      </w:rPr>
    </w:rPrDefault>
    <w:pPrDefault>
      <w:pPr>
        <w:spacing w:after="120" w:line="276" w:lineRule="auto"/>
      </w:pPr>
    </w:pPrDefault>
  </w:docDefaults>
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:qFormat/>
    <w:pPr>
      <w:spacing w:after="120" w:line="276" w:lineRule="auto"/>
    </w:pPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Title">
    <w:name w:val="Title"/>
    <w:basedOn w:val="Normal"/>
    <w:qFormat/>
    <w:pPr>
      <w:spacing w:before="0" w:after="300"/>
      <w:jc w:val="center"/>
    </w:pPr>
    <w:rPr>
      <w:rFonts w:ascii="Calibri Light" w:eastAsia="Calibri Light" w:hAnsi="Calibri Light"/>
      <w:b/>
      <w:sz w:val="56"/>
      <w:szCs w:val="56"/>
      <w:color w:val="2E74B5"/>
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="Heading 1"/>
    <w:basedOn w:val="Normal"/>
    <w:qFormat/>
    <w:pPr>
      <w:spacing w:before="240" w:after="120"/>
      <w:outlineLvl w:val="0"/>
    </w:pPr>
    <w:rPr>
      <w:rFonts w:ascii="Calibri Light" w:eastAsia="Calibri Light" w:hAnsi="Calibri Light"/>
      <w:b/>
      <w:sz w:val="32"/>
      <w:szCs w:val="32"/>
      <w:color w:val="2E74B5"/>
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading2">
    <w:name w:val="Heading 2"/>
    <w:basedOn w:val="Normal"/>
    <w:qFormat/>
    <w:pPr>
      <w:spacing w:before="200" w:after="100"/>
      <w:outlineLvl w:val="1"/>
    </w:pPr>
    <w:rPr>
      <w:rFonts w:ascii="Calibri Light" w:eastAsia="Calibri Light" w:hAnsi="Calibri Light"/>
      <w:b/>
      <w:sz w:val="26"/>
      <w:szCs w:val="26"/>
      <w:color w:val="2E74B5"/>
    </w:rPr>
  </w:style>
  <w:style w:type="paragraph" w:styleId="Heading3">
    <w:name w:val="Heading 3"/>
    <w:basedOn w:val="Normal"/>
    <w:qFormat/>
    <w:pPr>
      <w:spacing w:before="160" w:after="80"/>
      <w:outlineLvl w:val="2"/>
    </w:pPr>
    <w:rPr>
      <w:rFonts w:ascii="Calibri Light" w:eastAsia="Calibri Light" w:hAnsi="Calibri Light"/>
      <w:b/>
      <w:sz w:val="24"/>
      <w:szCs w:val="24"/>
      <w:color w:val="2E74B5"/>
    </w:rPr>
  </w:style>
</w:styles>`;
  }

  function createFontTableXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:fonts xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:font w:name="Calibri">
    <w:panose1 w:val="020F0502020204030204"/>
    <w:charset w:val="00"/>
    <w:family w:val="swiss"/>
    <w:pitch w:val="variable"/>
    <w:sig w:usb0="E0002AFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
  </w:font>
  <w:font w:name="Calibri Light">
    <w:panose1 w:val="020F0302020204030204"/>
    <w:charset w:val="00"/>
    <w:family w:val="swiss"/>
    <w:pitch w:val="variable"/>
    <w:sig w:usb0="E0002AFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
  </w:font>
</w:fonts>`;
  }

  function createSettingsXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:zoom w:percent="100"/>
  <w:defaultTabStop w:val="708"/>
  <w:characterSpacingControl w:val="doNotCompress"/>
  <w:compat>
    <w:compatSetting w:name="compatibilityMode" w:uri="http://schemas.microsoft.com/office/word" w:val="15"/>
  </w:compat>
</w:settings>`;
  }

  function createAppXml() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Bible Reflection Tool</Application>
  <DocSecurity>0</DocSecurity>
  <ScaleCrop>false</ScaleCrop>
  <SharedDoc>false</SharedDoc>
  <HyperlinksChanged>false</HyperlinksChanged>
  <AppVersion>16.0000</AppVersion>
</Properties>`;
  }

  function createCoreXml() {
    const now = new Date().toISOString();
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:title>Bible Verse Reflection</dc:title>
  <dc:creator>Bible Reflection Tool</dc:creator>
  <dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created>
  <dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified>
</cp:coreProperties>`;
  }

  // Public API
  return {
    Document: Document,
    Paragraph: Paragraph,
    Packer: Packer,
    HeadingLevel: HeadingLevel
  };
}));